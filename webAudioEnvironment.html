<!doctype html>

<html>
	<head>
		<!--<link href='https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300,700italic,400italic,300italic' rel='stylesheet' type='text/css'   > -->
		<link href='https://fonts.googleapis.com/css?family=Roboto+Condensed:300,300italic' rel='stylesheet' type='text/css'   >

		<script src='jquery.js'></script>

		<script src='jquery-ui.js'></script>
		<link rel='stylesheet' type='text/css' href='webAudioEnvironment.css'>
		<link rel='stylesheet' type='text/css' href='jquery-ui.css'>


	</head>
	<body>
		<h6>web audio signal processor</h6>
		<input
			type='button'
			class='create-node-button'
			data-nodetype='osc'
			value='Create Oscillator Node'
		>
		<input
			type='button'
			class='create-node-button'
			data-nodetype='gain'
			value='Create Gain Node'
		>
		<input
			type='button'
			class='create-node-button'
			data-nodetype='delay'
			value='Create Delay Node'
		>
		<input
			type='button'
			class='create-node-button'
			data-nodetype='panner'
			value='Create Panner Node'
		>
		<input
			type='button'
			class='create-node-button'
			data-nodetype='destination'
			value='Create Destination Node'
		>
			<div id='app-window'>
				<div id='background-layer'></div>
			</div>
	</body>
	<script>
//dont do shit til we load
$(function() {

	//create an audio context
	var audioContext = new (
		window.AudioContext ||
		window.webkitAudioContext
	)();

	gameInitialization = {
		initAppWindow () {
			var div, initOffset
			aw = $( '#background-layer');
			console.log(foregroundLines.canvas);
			$(backgroundLines.canvas).on('mousedown',function(e) {
				if (!e.shiftKey) {
					NodeOp.removeSelected();
				};
				$('#app-window').children('.selectbox').remove();
				div = $("<div class='selectbox'></div>");

				div.appendTo('#app-window');
				div.offset({ 'top' : event.pageY , 'left' : event.pageX });
				initOffset = div.offset()
			});
			$(document).on('mouseup',function() {
				if (div) {
					var selectTop = div.offset().top;
					var selectLeft = div.offset().left;
					var selectBottom = selectTop + div.height();
					var selectRight = selectLeft + div.width();

					$('#app-window').children('.node-controls').each( function(){
						var box = $(this);
						var boxTop = box.offset().top;
						var boxLeft = box.offset().left;
						var boxBottom = boxTop + box.height();
						var boxRight = boxLeft + box.width();
						console.log(boxTop, boxLeft, boxBottom, boxRight);
						console.log(selectTop, selectLeft, selectBottom, selectRight);
						var yIn = false;
						var xIn = false;

						if (boxTop > selectTop && boxTop < selectBottom || boxBottom < selectBottom && boxBottom > selectTop) {
							console.log ('y checks out...');
							if (boxLeft > selectLeft && boxLeft < selectRight || boxRight < selectRight && boxRight > selectLeft) {
								console.log ('x checks out...');
								box.addClass('selected');
							};

						};

					});

					div.remove();
					div = 0;
				};
			});
			$(document).on('mousemove', function() {
				if (div) {
					var x = initOffset.left - event.pageX;
					var y = initOffset.top - event.pageY;
					if (y < 0) {
						div.offset({top:initOffset.top});
						div.height(-y);
					} else {
						div.offset({top:event.pageY});
						div.height(y);
						console.log('div height is' + div.height() );
					};
					if (x < 0) {
						div.offset({left:initOffset.left});
						div.width(-x);
					} else {
						div.offset({left:event.pageX});
						div.width(initOffset.left - event.pageX);
					};
				};
			});
		}
	}

	SVG = {
		createCanvas : function( width, height, container, pos, z, pointerevents){
			var canvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			canvas.setAttribute('width', width);
			canvas.setAttribute('height', height);

			canvas.setAttribute('pointer-events', pointerevents);
			
			var htmlstring = '<div style="z-index: ' + z + '; position: ' + pos + '; pointer-events: ' + pointerevents + ';" top: 0px, left: 0px, height: 0></div>';
			console.log (htmlstring);
			var svgContain = $( htmlstring );
			container.prepend(svgContain);
			svgContain.append( canvas );    
			return canvas;
		},
		  createLine : function (x1, y1, x2, y2, color, w) {
			var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
			line.setAttribute('x1', x1);
			line.setAttribute('y1', y1);
			line.setAttribute('x2', x2);
			line.setAttribute('y2', y2);
			line.setAttribute('stroke', color);
			line.setAttribute('stroke-width', w);
			line.setAttribute('onmouseover',SVG.mouseOverLine); //doesnt work
			return line;
		  },

		  mouseOverLine : function(line, stroke) {
			line.setAttribute('stroke', stroke);
		  },
		updateLine: function (which, x1, y1, x2, y2) {
			which.setAttribute('x1', x1);
			which.setAttribute('y1', y1);
			which.setAttribute('x2', x2);
			which.setAttribute('y2', y2);
		},
		deleteLine: function (which) {
			which.remove();
		}
	}

	var LineContext = function( pos, z, pointerEvents) {
		this.canvas = SVG.createCanvas (
			$( '#app-window' ).width(),
			$( '#app-window' ).height(),
			$( '#app-window' ),
			pos,
			z,
			pointerEvents
		);
		//console.log (this.canvas);
	}
	var backgroundLines = new LineContext('absolute', '1', 'auto');
	var foregroundLines = new LineContext('absolute', '1200', 'none');
	
	gameInitialization.initAppWindow();

	//backgroundLines.canvas.css( top, 0);

	//creates relevant button for each node type
	$(' .create-node-button ').click ( function() {
		createNode (
			$( this ).data().nodetype	
		);
	});
	
	function updateConnectingLine (origin, end, line) {
		var y1 = origin.offset().top + origin.height()/2;
		var x1 = origin.offset().left + origin.width()/2;
		var y2 = end.offset().top + end.width()/2;
		var x2 = end.offset().left + end.width()/2;
		var appwindow = $( '#app-window' );
	    var offy = appwindow.offset().top;
		var offx = appwindow.offset().left;	

		SVG.updateLine( line, x1-offx, y1-offy, x2-offx, y2-offy);
	}




//lets define some objects nao. here's some nodes!
	var DelayNodeGUI = function() {
		this.node = audioContext.createDelay(10);

		//create control window
		this.controls = $("<div class='node-controls'></div>");
		$( '#app-window' ).append(this.controls);
		//we store the object in the window...
		this.controls.data('rootObj', this);

		NodeOp.createDragHandle(this.controls,'Delay');

		//MAKE ROW IO
		var currentrow = NodeOp.createRow(this.controls, 'io');
		//gets run as code in NodeOp.connection
		currentrow.data( 'node', this.node );

		var ioDisplay = $("<h1>IN / OUT</h1>");
		currentrow.append(ioDisplay);

		//MAKE ROW: DELAYTIME
		var currentrow = NodeOp.createRow(this.controls, 'delay-time');
		currentrow.data( 'node', this.node.delayTime );
		console.log (currentrow.data( 'node' ));

		var delayDisplay = $("<h1>DLY TIME</h1>");
		currentrow.append(delayDisplay);

		//ROW CONTROLS
		//numerical input
		currentrow.numberInput = $("<input type='number' value='.5' step='.1' max='10'>");
		currentrow.append(currentrow.numberInput);

		//we use parent() to get to object reference stored in its data and call a method
		//and we have to wrap the call in an anonymous function so we can do some maths...
		currentrow.numberInput.on ('keyup mouseup', function() {
			$( this ).closest( '.node-controls' ).data( 'rootObj' ).update( 'delayTime', $(this).val() );
		});
		this.update('delayTime', .5);
	}

	DelayNodeGUI.prototype.update = function(which, aValue) {
		if (which = 'delayTime') {
			stringCommand = 'this.node.' + which + '.value'; //this tells us which audioParam to deal with dynamically
			console.log (eval (stringCommand + ' = ' + aValue) ); //eval evaluates a string as code!
			eval (stringCommand + ' = ' + aValue);

			//this.controls.delayDisplay.html( (eval (stringCommand)).toFixed(2) );
			//valueParam = aValue; //this[which] means i can call use the string value of which as a variable name
			//this.controls.gainDisplay.html( (valueParam).toFixed(2) );
		}
	}

	var GainNodeGUI = function() {
		this.node = audioContext.createGain();

		//create control window
		this.controls = $("<div class='node-controls'></div>");
		$( '#app-window' ).append(this.controls);
		//we store the object in the window...
		this.controls.data('rootObj', this);

		NodeOp.createDragHandle(this.controls,'Gain');

		//MAKE ROW IO
		var currentrow = NodeOp.createRow(this.controls, 'io');
		//gets run as code in NodeOp.connection
		currentrow.data( 'node', this.node );

		var ioDisplay = $("<h1>IN / OUT</h1>");
		currentrow.append(ioDisplay);

		//MAKE ROW: GAIN
		var currentrow = NodeOp.createRow(this.controls, 'gain');
		currentrow.data( 'node', this.node.gain );
		console.log (currentrow.data( 'node' ));

		var ioDisplay = $("<h1>GAIN</h1>");
		currentrow.append(ioDisplay);

		//ROW CONTROLS
		//numerical input
		currentrow.numberInput = $("<input type='number' value='.5' step='.01'>");
		currentrow.append(currentrow.numberInput);

		//we use parent() to get to object reference stored in its data and call a method
		//and we have to wrap the call in an anonymous function so we can do some maths...
		currentrow.numberInput.on ('keyup mouseup', function() {
			$( this ).closest( '.node-controls' ).data( 'rootObj' ).update( 'gain', $(this).val() );
		});

		//END ROW
/*
		//NEW ROW data
		currentrow = NodeOp.createRow(this.controls, 'data'); //new row 
		//simply displays current volume (as percent)
		this.controls.gainDisplay = $( "<p>" + this.node.gain.value +  "%</p>" );
		currentrow.append (this.controls.gainDisplay);

		//END ROW
*/
		this.update ('gain', '0.5');
	}

	GainNodeGUI.prototype.update = function(which, aValue) {
		if (which = 'gain') {
			stringCommand = 'this.node.' + which + '.value'; //this tells us which audioParam to deal with dynamically
			console.log (eval (stringCommand + ' = ' + aValue) ); //eval evaluates a string as code!
			eval (stringCommand + ' = ' + aValue);

			//this.controls.gainDisplay.html( (eval (stringCommand)).toFixed(2) );
			//valueParam = aValue; //this[which] means i can call use the string value of which as a variable name
			//this.controls.gainDisplay.html( (valueParam).toFixed(2) );
		}
	}

	var OscNodeGUI = function () {

		this.node = audioContext.createOscillator();
		this.node.start();

		//create control window
		this.controls = $("<div class='node-controls'></div>");
		$( '#app-window' ).append(this.controls);
		//we store the object in the window...
		this.controls.data('rootObj', this);

		NodeOp.createDragHandle(this.controls,'Oscillator');

		//MAKE ROW
		currentrow = NodeOp.createRow(this.controls, 'output'); //new row for output
		currentrow.data( 'node', this.node );
		var rowDisplay = $("<h1>OUTPUT</h1>");
		currentrow.append(rowDisplay);

		//NEW ROW
		var currentrow = NodeOp.createRow(this.controls, 'frequency'); //new row for frequency io
		currentrow.data( 'node', this.node.frequency );
		rowDisplay = $("<h1>FREQ</h1>");
		currentrow.append(rowDisplay);

		//ROW CONTROLS

		//create frequency numerical input
		currentrow.numberInput = $("<input type='number' value='440'>");
		currentrow.append(currentrow.numberInput);

		//we use parent() to get to object reference stored in its data and call a method
		//and we have to wrap the call in an anonymous function so we can do some maths...
		currentrow.numberInput.on ('keyup mouseup', function() {
			$( this ).closest( '.node-controls' ).data( 'rootObj' ).update( 'frequency', this.value );
		});

		//END ROW

		//NEW ROW
		currentrow = NodeOp.createRow(this.controls, 'type'); //new row for wavetype
		rowDisplay = $("<h1>TYPE</h1>");
		currentrow.append(rowDisplay);
		rowDisplay = $("<h1>SINE</h1>");
		currentrow.append(rowDisplay);

		currentrow.append(currentrow.typeInput);


		//gets run as code in NodeOp.connection
		currentrow.data( 'node', this.node.type ); //type = wavetype

		//END ROW

		//NOT TEMPORARY
		this.update ('frequency', 440);

	}

	OscNodeGUI.prototype.update = function(which, value) {
		if (which = 'frequency') {		
			this.node.frequency.value = value;
			//this.controls.freqDisplay.html( this.node.frequency.value.toFixed(2) + "hz " + this.node.type );
		}
	}
		
	StereoPannerNodeGUI = function(type, value) {

		this.node = audioContext.createStereoPanner();

		//create control window
		this.controls = $("<div class='node-controls'></div>");
		$( '#app-window' ).append(this.controls);
		//we store the object in the window...
		this.controls.data('rootObj', this);

		NodeOp.createDragHandle(this.controls,'Stereo Pan');

		//NEW ROW
		var currentrow = NodeOp.createRow(this.controls, 'io'); //new row io
		currentrow.data( 'node', this.node );
		var ioDisplay = $("<h1>IN / OUT</h1>");
		currentrow.append(ioDisplay);


		//END ROW

		//NEW ROW
		var currentrow = NodeOp.createRow(this.controls, 'panner'); //new row io
		currentrow.data( 'node', this.node.pan );
		var ioDisplay = $("<h1>PAN</h1>");
		currentrow.append(ioDisplay);

		//ROW CONTROLS

		//create frequency numerical input
		currentrow.numberInput = $("<input type='number' value='0' min='-1' max='1' step='.1'>");
		currentrow.append(currentrow.numberInput);

		//we use parent() to get to object reference stored in its data and call a method
		//and we have to wrap the call in an anonymous function so we can do some maths...
		currentrow.numberInput.on ('keyup mouseup', function() {
			$( this ).closest( '.node-controls' ).data( 'rootObj' ).update( 'which', this.value );
		});

		//END ROW
		this.update('pan', 0);

	};

	StereoPannerNodeGUI.prototype.update = function(which, value) {
		if (which = 'pan') {		
			this.node.pan.value = value;
			//this.controls.panDisplay.html( this.node.pan.value.toFixed(2) );
		}
	}

	AnalyserNodeGUI = function(type, value) {

		//create control window
		this.controls = $("<div class='node-controls'></div>");
		$( '#app-window' ).append(this.controls);
		//we store the object in the window...
		this.controls.data('rootObj', this);

		NodeOp.createDragHandle(this.controls,'Analyser');

		//NEW ROW
		var currentrow = NodeOp.createRow(this.controls, 'input'); //new row input

		//gets run as code in NodeOp.connection
		currentrow.data( 'node', audioContext.destination );

		var inputDisplay = $("<h1>INPUT</h1>");
		currentrow.append(inputDisplay);
		//END ROW


	};

	//makesa sound come outcha speakas
	DestinationNodeGUI = function(type, value) {

		//create control window
		this.controls = $("<div class='node-controls'></div>");
		$( '#app-window' ).append(this.controls);
		//we store the object in the window...
		this.controls.data('rootObj', this);

		NodeOp.createDragHandle(this.controls,'Destination');

		//NEW ROW
		var currentrow = NodeOp.createRow(this.controls, 'input'); //new row input

		//gets run as code in NodeOp.connection
		currentrow.data( 'node', audioContext.destination );

		var inputDisplay = $("<h1>INPUT</h1>");
		currentrow.append(inputDisplay);
		//END ROW

		//NEW ROW
		var currentrow = NodeOp.createRow(this.controls, 'data'); //new row input

		//gets run as code in NodeOp.connection
		currentrow.data( 'node', audioContext.destination );

		var inputDisplay = $("<h1>OUTPUT 1 <br> (.L)</h1>");
		currentrow.append(inputDisplay);
		//END ROW

		//NEW ROW
		var currentrow = NodeOp.createRow(this.controls, 'data'); //new row input

		//gets run as code in NodeOp.connection
		currentrow.data( 'node', audioContext.destination );

		var inputDisplay = $("<h1>OUTPUT 2 <br>  (.R)</h1>");
		currentrow.append(inputDisplay);
		//END ROW
	}



//Here are the operations that accomplish creating and maintaining nodes

	NodeOp = {
		//removes all selected elements
		removeSelected : function() {
			//console.log ($(this));
			$( '#app-window' ).find( '.selected' ).each(function() {
					$(this).removeClass('selected' )
			});
		},	
		//initializes output handle draggability does NOT create handle
		initOutputHandle : function(handle) {
			handle.draggable({
			revertDuration: 200,
			revert: function() {
				console.log ( 'revert ' + handle );
				$(handle).removeClass('selected');

					//passing values to active line
				handle.updateLine = setInterval(function() {
					var notch = handle.siblings( '.output-notch' ) [0];

					updateConnectingLine (handle, $(notch) ,foregroundLines.canvas.aline);
					console.log ( 'wheeee' );
				}, 1);
				console.log ('true');
				return('true');
			},
				drag: function() {
						var notch = handle.siblings( '.output-notch' ) [0];
						updateConnectingLine ( handle, $( notch ) ,foregroundLines.canvas.aline);
				},
				start: function() {
					$(handle).closest('.node-controls ').css('z-index', '1500'); //whole parent can we make it just output handle?
					$(handle).addClass('selected');

					//going to have to do all this svg shit differently
					var line = SVG.createLine( 0,0,0,0, $(handle).css('background-color'), 4, 'true'); //it gets updated right away anyway...

					//CURRENTLY HARDCODED AS foregroundLines WATCH OUT
					foregroundLines.canvas.aline = foregroundLines.canvas.appendChild(line);

				},
				stop: function(event, ui) {
					console.log('stop');
					$(handle).closest('.node-controls ').css('z-index', '1'); //whole parent can we make it just output handle?
					$(foregroundLines.canvas).empty();					
					clearInterval (handle.updateLine);
				}
			});
		},
		disconnectByOutputHandle : function (handle) {
			var notch = handle.data('connected-notch');
			NodeOp.disconnection(handle, notch);
			SVG.deleteLine(handle.data('connected-line'));

			var outputNotchHandleArray = $( notch.data('connected-handles') );
			outputNotchHandleArray.each( function(index, element) {
				if (this == handle) {
					console.log ('before splice: ' + outputNotchHandleArray );
					outputNotchHandleArray.splice(index, 1);
					console.log ('after splice: ' + outputNotchHandleArray );
				} else {
					console.log ('search');
				}
			});
			notch.data('connected-handles', outputNotchHandleArray);
			console.log (outputNotchHandleArray.length);
			if (outputNotchHandleArray.length == 0) {
				//remove our handle from the notch so it doesn't tel svg to draw lines
				notch.removeData('connected-handles');
				//make output handle look like it does when no outputs!
				NodeOp.resetOutputHandle( notch.siblings( '.output-handle' ).not( '.is-input') );
			}
			handle.remove();
		},
		resetOutputHandle : function (handle) {
			console.log ('reset output handle ' + handle);
			outputHandle = $(handle);
			outputHandle.css({
				'margin-top' : '-9px' ,
				'top' : '50%',
				'right' : '0px',
				'box-shadow' : '0px 0px 1px 1px rgba(0,0,0,.5)',
				'-webkit-box-shadow' : '0px 0px 1px 1px rgba(0,0,0,.5)',
				'-moz-box-shadow' : '0px 0px 1px 1px rgba(0,0,0,.5)'
			});
		},
		initOutputAsInputHandle : function (handle)  {
			console.log(handle);
			handle.click(function() {

				NodeOp.disconnectByOutputHandle(handle)
				console.log('click click');
			});
		},

		initInputHandle : function(handle) {
			handle.droppable({
				accept: '.output-handle',
				activeClass : '.selected' ,
				tolerance : 'pointer',
				drop : function(event, ui) {
					//GOTTA BE A BETTER WAY SPLIT THIS SHIT UP!!

					var outputHandle = ui.draggable;
					//console.log(outputHandle.val);
					//var style = outputHandle.css();
					//console.log ( style);

					//our output-handle is going to a foreign land
					//we need to make sure it rememberswhere home is...

					connectedNotch = outputHandle.siblings('.output-notch' );

					


					//test connection, if true do a whole bunch of sheeit
					if ( NodeOp.connection( connectedNotch, $(this) ) ) {

					outputHandle.data('node-controls', outputHandle.closest('.node-controls' ) ); //store control window of parent
					outputHandle.data('connected-notch', connectedNotch );
					
					//the notch must remember too
					//make an array so we can do multi-out?
					
					console.log ('connected notch handle data reads' + connectedNotch.data('connected-handles') );

					if (connectedNotch.data('connected-handles') === undefined ) {
						connectedNotch.data('connected-handles', [outputHandle]);
					} else {
						connectedNotch.data('connected-handles').push(outputHandle);
					}
						//create a new output handle back at home
						var row = outputHandle.closest('.row'); //need this for later..

						outputHandle.addClass ( 'is-input' ); //registers that this output went somewhere!
						connectedNotch.addClass ('sending-output' ); //registers that this output is sending signal somewhere!
		
						//sloppy list of css to revert after we change parents...
						//put this in an array and get it out of here!
						var bgcol = outputHandle.css ( 'background-color' );
						var col = outputHandle.css ( 'color' );
						var ff = outputHandle.css ( 'font-family' );
						var fs = outputHandle.css ( 'font-size' );
						var lh = outputHandle.css ( 'line-height' );
						var fw = outputHandle.css ( 'font-weight' );
						var fst = outputHandle.css ( 'font-style' );
						var shadow = '-5px 0px 10px 0px ' + bgcol;

						//changing the parent to the input node we are connecting to...			

						outputHandle.appendTo (this.closest('.row'));

						//var topval = outputHandle.siblings('.is-input').length * -4;

						outputHandle.css({ top : '50%', left : -5 + 'px' , 'margin-top' : -9 + 'px'});
						outputHandle.draggable('option','revert','false');
						outputHandle.draggable('destroy');
						console.log ('draggable destroyed' + outputHandle);
						outputHandle.removeClass('selected');
						//outputHandle.css( style );

						//re-render handle style there must be a better way ughughgu
						outputHandle.css( 'background-color', col );
						outputHandle.css( 'color', bgcol );
						outputHandle.css( 'border-color', bgcol );
						outputHandle.css( 'font-family', ff );
						outputHandle.css( 'font-size', fs );	
						outputHandle.css( 'line-height', lh );
						outputHandle.css( 'font-weight', fw );;
						outputHandle.css( 'font-style', fst );	
						outputHandle.css( '-webkit-box-shadow', shadow);

						
						//now we make a new output Handle at home...

						console.log (row);
						var newOutputHandle = outputHandle.clone();
						newOutputHandle.removeClass ('is-input');
						newOutputHandle.appendTo(row);
						newOutputHandle.removeAttr('style');
						newOutputHandle.css({'top': '50%'});
						newOutputHandle.css({'right': '-5px', 'margin-top' : '-9px'});
						newOutputHandle.css( '-webkit-box-shadow', '5px 0px 10px 0px ' + bgcol );
						NodeOp.initOutputHandle (newOutputHandle);


						//made it!!
						//lets draw a line to celebrate!

						//get these foreground lines out of my way
						$(foregroundLines.canvas).empty();
						//and draw some nice background lines instead
						var line = SVG.createLine( 0,0,100,100, bgcol, 2, 'true'); //it gets updated right away anyway...

						outputHandle.data( 'connected-line', backgroundLines.canvas.appendChild(line) );
						//backgroundLines.canvas.appendChild(line);
						//outputHandle.val( 'line', line );


						updateConnectingLine (outputHandle, outputHandle.data( 'connected-notch' ), outputHandle.data( 'connected-line' ) );

						console.log('drop');

						//now we make our output Handle an output as input handle...
						console.log (outputHandle);
						setTimeout( function() {NodeOp.initOutputAsInputHandle (outputHandle)}, 500 );
						console.log('output as input handle:' + outputHandle );
					}
				},
				over : function(event) {

				}
			});
		},
		connection : function(from, to) {
			//this is where we connect two audio nodes using data stored in strings in the ROW containing our handles...
			var toNode = eval ( to.parents( '.row' ).data( 'node' ) );
			var fromNode = eval ( from.parents( '.row' ).data( 'node' ) );
			console.log (' can ' + fromNode + 'connect to' + toNode + '?');

			//apparently there is no way to check if audionodes are already connected so we gotta do our own thing...

			if (fromNode == '[object AudioParam]') {
				console.log ('no, output is AudioParam and I havent made that work yet');
				return false;
			} else {
				console.log ('unless they are already connected?');
				//how do i tell???

				//there is no way in Web Audio API to check if two nodes are connected, but...
				//disconnect throws an ERROR message
				//so if we disconnect but catch it in a try...
				//then we can perform a 'check'
				try {
					fromNode.disconnect(toNode);
					console.log ('they were already connected');
					fromNode.connect(toNode)
					return false;
				}
				catch(err) {
					fromNode.connect(toNode)
					console.log('connection made!');
					return true;
				};
			};		
		},

		disconnection : function(to, from) {
			//this is where we connect two audio nodes using data stored in strings in the ROW containing our handles...
			var toNode = eval ( to.parents( '.row' ).data( 'node' ) );
			var fromNode = eval ( from.parents( '.row' ).data( 'node' ) );
			console.log ('severing connection between ' + fromNode + ' and ' + toNode + '?');
			fromNode.disconnect(toNode);
			console.log('yes!');
			return true;
		},

		onControlsDrag : function(actual){

			$('#app-window').children('.selected').each(function() {

			var which = $(this);
			var offsetPos = which.data('offsetPosition');

			if (!which.is(actual) ) {
				which.offset({ 'top' : event.pageY - offsetPos.top , 'left' : event.pageX - offsetPos.left});
			};
				//we have to update all connected lines!
				which.find('.is-input').each(function() {
					var outputHandle = $(this);
					updateConnectingLine ( outputHandle , outputHandle.data ('connected-notch') , outputHandle.data('connected-line') )
				});
			

				which.find('.sending-output').each(function() {

				//we save all output handles connected to output notch to an array called connected-handles
				//and we iterate through them to draw!

				var outputNotch = $(this);
				var outputNotchHandleArray = $( outputNotch.data('connected-handles') );
				outputNotchHandleArray.each( function() {
					var ourHandle = this;
					updateConnectingLine ( ourHandle , outputNotch , ourHandle.data('connected-line') )
				});
				
			});

			});
		},
		//creates the top bar handle for dragging window around
		createDragHandle : function(controls, title) {
			//creates top bar to drag it by --no reference needed!
			var appender = $("<div class='drag-handle'>" + title + "</div>");
			controls.append(appender);
			appender.append ("<span class ='mini-button '>_</span>");
			appender.append ("<span class ='close-button'>x</span>");
			controls.draggable({
				containment: $( '#app-window' ),
				handle: '.drag-handle',
				stack: '.node-controls',
				start: function(e) {
					var actual = $(this);
					
					//remove all other selected if not holding shift
					if (!e.shiftKey) {
						NodeOp.removeSelected();
					}
					//this bullshit is to deal with dragging a bunch of selected shit at once
					$('#app-window').children('.selected').not(actual).each(function() {
						var thisPos = $(this).offset();
						var myPos = actual.offset();
						console.log( thisPos, myPos);
						var endPos = {top: event.pageY - thisPos.top , left: event.pageX - thisPos.left}
						$(this).data('offsetPosition', endPos);
						console.log (endPos);
					});

					//NodeOp.removeSelected();
					//controls.css('opacity', '0.8');
					controls.addClass('selected');
				},
				drag: function() {
					NodeOp.onControlsDrag( $(this) );
				},
				stop: function() {
					//controls.css('opacity', '1');
				//	controls.removeClass('selected');
					
					//make sure nothing is misaligned at end of drag!
					NodeOp.onControlsDrag( $(this) );
				}
			});
			controls.click(function(e) {
				if (!e.shiftKey) {
					NodeOp.removeSelected();
				}
				controls.addClass('selected');
			});
			controls.children( ' .drag-handle ' ).dblclick(function() {
				console.log ('double click!');
				//here we do shit to minimize window
			});
		},
		createRow : function (controls, type) {
			var row = $( "<div class='row " + type + "  '> </div>");
			controls.append (row);
			var input = true;
			var output = true;
			var symbol = false;
			var cssString = 'color: magenta'

			switch(type) {
				case ('frequency') :
					symbol ='&#402;';
					break;
				case ('gain') :
					symbol = 'A';
					break;
				case ('type') :
					symbol = 'w'; //for wave, type is wavetype
					break;

				case ('delay-time') :
					symbol = 'T';
					break;

				case ('panner') :
					symbol = 'p';

					break;
				case ('data') :
					
					input = false;
					output = false;
					break;
				case ('input') :
					symbol = 'S'
					output = false;
					break;
				case ('output') :
					symbol = 'S'
					input = false;
					break;
				case ('io') :
					symbol = 'S'
					break;
			}
			
			if (input) {
				//leave if we don't want an io
				//makes our input handle
				if (!symbol) {symbol = '<bold>I</bold>'};

				row.inputHandle = $( "<div class ='input-handle noselect'>"+ symbol + "</div>" );
				row.append (row.inputHandle);
				row.inputHandle.css({ cssString });

				NodeOp.initInputHandle (row.inputHandle);
			}

			if (symbol == '<bold>I</bold>') {
				symbol = false;
			}

			if (output) {

				if (!symbol)  {symbol = '<bold>O</bold>'};

				//creates a notch for when we drag output away
				row.outputNotch = $( "<div class ='output-notch noselect'></div>" );
				row.append (row.outputNotch);

				//creates a handle we can drag an output out of
				row.outputHandle = $( "<div class ='output-handle noselect'>" + symbol + "</div>" );
				//console.log(row.outputHandle);
				row.append(row.outputHandle);
				row.outputHandle.css({ cssString });

				//THIS could be done better!!
				NodeOp.initOutputHandle (row.outputHandle);
			}

			//so we can add controls
			return row;
		}


	};

	function createNode (nodetype) {
		var node;			//a reference to the node we're creating
		var locateNode;		//the location in nodeArray we want to store that reference

		switch(nodetype) {
			case ('osc'):
				node = new OscNodeGUI();
				break;

			case ('gain'):
				node = new GainNodeGUI();
				break;

			case ('delay'):
				node = new DelayNodeGUI();
				break;

			case ('panner'):
				node = new StereoPannerNodeGUI();
				break;

			case ('destination'):
				node = new DestinationNodeGUI();
				break;

			default:

				console.log ('ERROR: Node kind not defined!');

		}

		//nodeArray.push (node);
		//console.log(nodeArray);
		//console.log (nodeArray[0].controls.freq.val() );
	}
});
	</script>
</html>
